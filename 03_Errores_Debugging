## 3. Manejo de Errores y Debugging en Node.js


### 3.1. **Manejo de Errores en Node.js**

El manejo de errores es crucial para escribir código robusto y evitar que tu aplicación falle inesperadamente.
Para una información más detallada no dudes ir a la [**web de Node**](https://nodejs.org/docs/latest/api/errors.html)(Documentación oficial)

#### a. **Errores Síncronos con `try/catch`**

La técnica más básica para manejar errores en Node.js es usando bloques `try/catch`, que son especialmente útiles para errores que ocurren de forma síncrona.

```javascript
try {
  const result = functionSync();
  console.log("Resultado de la función Síncrona: ",result);
} catch (error) {
  console.error("Error encontrado en la función Síncrona:", error.message);
}
```

Este patrón es ideal cuando el código puede lanzar un error directamente en el mismo ciclo de ejecución.

#### b. **Errores Asíncronos con Promesas**

Las promesas proporcionan una forma estructurada de manejar operaciones asíncronas y los errores que ocurren en ellas.

```javascript
functionAsync()
  .then((result) => console.log("Resultado de la función Asíncrona: ",result))
  .catch((error) => console.error("Error en la promesa:", error.message));
```

El método `.catch()` captura cualquier error que ocurra durante la ejecución de la promesa.

#### c. **Manejo de Errores con `async/await`**

Con `async/await`, puedes escribir código asíncrono de manera más sencilla y limpia, utilizando bloques `try/catch` para capturar errores.

```javascript
async function fetchData() {
  try {
    const data = await functionAsync();
    console.log(data);
  } catch (error) {
    console.error("Error en async/await:", error.message);
  }
}

fetchData();
```

Aquí, el bloque `try/catch` te permite manejar errores en código asíncrono sin necesidad de utilizar `.then()` y `.catch()`.

---

### 2. **Debugging en Node.js**

La depuración te permite identificar problemas y fallos en tu código de manera eficiente. Node.js tiene varias herramientas integradas y externas para hacer esto.

#### a. **Depuración con `node inspect`**

Node.js incluye un depurador integrado llamado `inspect`. Para usarlo, puedes iniciar tu aplicación con el siguiente comando:

```bash
node --inspect-brk app.js
```

Esto abrirá un puerto de depuración en `localhost:9229`. Puedes conectarte a este puerto desde Chrome DevTools o cualquier cliente de depuración compatible.

- **`--inspect-brk`**: Pausa la ejecución en el primer script para permitirte comenzar a depurar desde el inicio.

Una vez conectado, puedes utilizar puntos de interrupción (breakpoints), inspeccionar variables y seguir el flujo del programa.

#### b. **Depuración con `ndb`**

`ndb` es una herramienta mejorada para depuración en Node.js, que simplifica el proceso al proporcionar una interfaz interactiva. Para instalarla:

```bash
npm install -g ndb
```

Luego, simplemente ejecuta tu archivo con `ndb`:

```bash
ndb app.js
```

Esto abrirá una nueva ventana del navegador con una interfaz similar a Chrome DevTools, pero optimizada para Node.js. Desde allí, puedes establecer puntos de interrupción y depurar como lo harías en el navegador.

---

### 3. **Logs Efectivos en Node.js**

Los logs son esenciales para rastrear el comportamiento de una aplicación y detectar errores. Usar `console.log` es útil, pero para aplicaciones más grandes y complejas, es mejor utilizar bibliotecas de logging avanzadas como **Winston** o **Pino**.

#### a. **Logs con Winston**

Winston es una de las bibliotecas más populares para logging en Node.js. Te permite personalizar los niveles de logs, crear múltiples transportes (como archivo o consola), y mucho más.

1. **Instalación**:

   ```bash
   npm install winston
   ```

2. **Ejemplo básico**:

   ```javascript
   const winston = require("winston");

   const logger = winston.createLogger({
     level: "info",
     format: winston.format.json(),
     transports: [
       new winston.transports.Console(),
       new winston.transports.File({ filename: "error.log", level: "error" }),
     ],
   });

   logger.info("Esto es un log de información");
   logger.error("Esto es un log de error");
   ```

   En este ejemplo:

   - Se registran mensajes de `info` en la consola.
   - Los errores (`error`) se registran tanto en la consola como en el archivo `error.log`.

#### b. **Logs con Pino**

Pino es una biblioteca de logging más ligera y orientada al rendimiento, ideal para aplicaciones de alta concurrencia.

1. **Instalación**:

   ```bash
   npm install pino
   ```

2. **Ejemplo básico**:

   ```javascript
   const pino = require("pino");
   const logger = pino({ level: "info" });

   logger.info("Esto es un log informativo");
   logger.error("Esto es un error grave");
   ```

   Pino también permite serializar objetos grandes de manera eficiente y soporta transporte de logs a archivos.

#### c. **Diferencias entre Winston y Pino**

- **Winston** es más flexible y soporta múltiples transportes, como enviar logs a bases de datos o sistemas externos.
- **Pino** es más rápido y está optimizado para rendimiento en aplicaciones que generan grandes volúmenes de logs.

---

### Conclusión

El manejo de errores y debugging son aspectos críticos en el desarrollo de aplicaciones Node.js modernas. Usando `try/catch`, promesas, `async/await` y herramientas como `node inspect` y `ndb`, puedes identificar y solucionar problemas más rápido. Además, con bibliotecas como **Winston** o **Pino**, puedes implementar un sistema de logs robusto y eficiente para monitorear el estado y errores de tu aplicación en producción.
